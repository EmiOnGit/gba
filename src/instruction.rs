use crate::{
    bus::OpCode,
    cpu::{V16, V8},
};

pub enum AddressMove {
    Add(u16),
    To(u16),
}
impl AddressMove {
    pub fn apply(self, pc: u16) -> u16 {
        match self {
            AddressMove::Add(v) => pc + v,
            AddressMove::To(v) => v,
        }
    }
}
#[derive(Clone, Debug)]
pub enum Instruction {
    Nop,
    Load16Mem,
    Store8Mem,
    Decrement16,
    Increment16,
    Increment8,
    Decrement8,
    Load8Mem,
    RotateLeftCircle,
    StoreSP,
    Load16Meminto8,
    Add16toHL,
    RotateRightCircle,
    RotateRight,
    RotateLeft,
    Stop,
    JumpRelative,
    StoreHlIncr,
    Daa,
    Load8MemHlIncr,
    ComplementA,
    StoreHlDecr,
    IncMemHl,
    DecMemHl,
    StoreXMemHl,
    SetCarryFlag,
    Load8MemHlDecr,
    FlipCarryFlag,
    Load8into8,
    Halt,
    Add8toA,
    AddMemToA,
    Add8AndFlagToA,
    AddMemHlAndFlagToA,
    Sub8fromA,
    SubMemToA,
    Sub8AndFlagToA,
    SubMemHlAndFlagToA,
    And8A,
    AndMemHlA,
    Xor8A,
    XorMemHlA,
    Or8A,
    OrMemHlA,
    Compare8A,
    CompareMemHlA,
    ReturnIfFlag,
    Pop16,
    JumpIfFlag,
    Jump16,
    CallIfFlag,
    Push16,
    Add8ImmToA,
    Sub8ImmToA,
    And8ImmToA,
    Or8ImmToA,
    CallN,
    Return,
    ReturnInterrupt,
    Call,
    AddImmAndFlagToA,
    SubImmAndFlagToA,
    XorImmToA,
    CompareImmToA,
    StoreAToIoImm,
    ReadAFromIoImm,
    StoreAToIoC,
    ReadAFromIoC,
    DisableInterrupts,
    AddImmAsSignedToSp,
    StoreAinMemHl,
    LoadAfromMemHl,
    LoadSignedImmPlusSpInHl,
    LoadHlinSp,
    EnableInterrupts,
    TwoByteInstruction,
}

impl From<OpCode> for Instruction {
    fn from(op: OpCode) -> Self {
        let op = op.0;
        println!("op {op:x}");
        let n0 = (op & 0xF0) >> 4; // first nibble of op
        let n1 = op & 0x0F; // second nibble of op
        match (n0, n1) {
            (0x0, 0x0) => Self::Nop,
            (0x0..=0x3, 0x1) => Self::Load16Mem,
            (0x0..=0x1, 0x2) => Self::Store8Mem,
            (0x7, 0x0..=0x5) => Self::Store8Mem,
            (0x7, 0x7) => Self::Store8Mem,
            (0x0..=0x3, 0xB) => Self::Decrement16,
            (0x0..=3, 0x3) => Self::Increment16,
            (0x0..=0x2, 0x4) => Self::Increment8,
            (0x0..=0x3, 0xC) => Self::Increment8,
            (0x0..=0x2, 0x5) => Self::Decrement8,
            (0x0..=0x3, 0xD) => Self::Decrement8,
            (0x0..=0x2, 0x6) => Self::Load8Mem,
            (0x0..=0x3, 0xE) => Self::Load8Mem,
            (0x0, 0x7) => Self::RotateLeftCircle,
            (0x0, 0x8) => Self::StoreSP,
            (0x0..=0x3, 0x9) => Self::Add16toHL,
            (0x0..=0x1, 0xA) => Self::Load16Meminto8,
            (0x4..=0x6, 0x6) => Self::Load16Meminto8,
            (0x4..=0x7, 0xE) => Self::Load16Meminto8,
            (0x0, 0xF) => Self::RotateRightCircle,
            (0x1, 0x0) => Self::Stop,
            (0x1, 0x7) => Self::RotateLeft,
            (0x1..=0x3, 0x8) => Self::JumpRelative,
            (0x2..=0x3, 0x0) => Self::JumpRelative,
            (0x1, 0xF) => Self::RotateRight,
            (0x2, 0x2) => Self::StoreHlIncr,
            (0x2, 0x7) => Self::Daa,
            (0x2, 0xA) => Self::Load8MemHlIncr,
            (0x2, 0xF) => Self::ComplementA,
            (0x3, 0x2) => Self::StoreHlDecr,
            (0x3, 0x4) => Self::IncMemHl,
            (0x3, 0x5) => Self::DecMemHl,
            (0x3, 0x6) => Self::StoreXMemHl,
            (0x3, 0x7) => Self::SetCarryFlag,
            (0x3, 0xA) => Self::Load8MemHlDecr,
            (0x3, 0xF) => Self::FlipCarryFlag,
            (0x4..=0x7, 0xF) => Self::Load8into8,
            (0x4..=0x6, 0x0..=0x5) => Self::Load8into8,
            (0x4..=0x6, 0x7..=0xD) => Self::Load8into8,
            (0x7, 0x8..=0xD) => Self::Load8into8,
            (0x7, 0x6) => Self::Halt,
            (0x8, 0x0..=0x5) => Self::Add8toA,
            (0x8, 0x7) => Self::Add8toA,
            (0x8, 0x6) => Self::AddMemToA,
            (0x8, 0x8..=0xD) => Self::Add8AndFlagToA,
            (0x8, 0xF) => Self::Add8AndFlagToA,
            (0x8, 0xE) => Self::AddMemHlAndFlagToA,
            (0x9, 0x0..=0x5) => Self::Sub8fromA,
            (0x9, 0x7) => Self::Sub8fromA,
            (0x9, 0x6) => Self::SubMemToA,
            (0x9, 0x8..=0xD) => Self::Sub8AndFlagToA,
            (0x9, 0xF) => Self::Sub8AndFlagToA,
            (0x9, 0xE) => Self::SubMemHlAndFlagToA,
            (0xA, 0x0..=0x5) => Self::And8A,
            (0xA, 0x7) => Self::And8A,
            (0xA, 0x6) => Self::AndMemHlA,
            (0xA, 0x8..=0xD) => Self::Xor8A,
            (0xA, 0xF) => Self::Xor8A,
            (0xA, 0xE) => Self::XorMemHlA,
            (0xB, 0x0..=0x5) => Self::Or8A,
            (0xB, 0x7) => Self::Or8A,
            (0xB, 0x6) => Self::OrMemHlA,
            (0xB, 0x8..=0xD) => Self::Compare8A,
            (0xB, 0xF) => Self::Compare8A,
            (0xB, 0xE) => Self::CompareMemHlA,
            (0xC..=0xD, 0x0) => Self::ReturnIfFlag,
            (0xC..=0xD, 0x8) => Self::ReturnIfFlag,
            (0xC..=0xF, 0x1) => Self::Pop16,
            (0xC..=0xD, 0x2) => Self::JumpIfFlag,
            (0xC..=0xD, 0xA) => Self::JumpIfFlag,
            (0xC, 0x3) => Self::Jump16,
            (0xE, 0x9) => Self::Jump16,
            (0xC..=0xD, 0x4) => Self::CallIfFlag,
            (0xC..=0xD, 0xC) => Self::CallIfFlag,
            (0xC..=0xF, 0x5) => Self::Push16,
            (0xC, 0x6) => Self::Add8ImmToA,

            (0xD, 0x6) => Self::Sub8ImmToA,
            (0xE, 0x6) => Self::And8ImmToA,
            (0xF, 0x6) => Self::Or8ImmToA,

            (0xC..=0xF, 0x7) => Self::CallN,
            (0xC..=0xF, 0xF) => Self::CallN,
            (0xC, 0x9) => Self::Return,
            (0xD, 0x9) => Self::ReturnInterrupt,
            (0xC, 0xD) => Self::Call,
            (0xC, 0xE) => Self::AddImmAndFlagToA,
            (0xD, 0xE) => Self::SubImmAndFlagToA,
            (0xE, 0xE) => Self::XorImmToA,
            (0xF, 0xE) => Self::CompareImmToA,
            (0xE, 0x0) => Self::StoreAToIoImm,
            (0xF, 0x0) => Self::ReadAFromIoImm,
            (0xE, 0x2) => Self::StoreAToIoC,
            (0xF, 0x2) => Self::ReadAFromIoC,
            (0xF, 0x3) => Self::DisableInterrupts,
            (0xE, 0x8) => Self::AddImmAsSignedToSp,
            (0xE, 0xA) => Self::StoreAinMemHl,
            (0xF, 0xA) => Self::LoadAfromMemHl,
            (0xF, 0x8) => Self::LoadSignedImmPlusSpInHl,
            (0xF, 0x9) => Self::LoadHlinSp,
            (0xF, 0xB) => Self::EnableInterrupts,
            (0xC, 0xB) => Self::TwoByteInstruction,
            (0xD, 0x3)
            | (0xE, 0x3)
            | (0xE, 0x4)
            | (0xF, 0x4)
            | (0xD, 0xB)
            | (0xE, 0xB)
            | (0xE, 0xC)
            | (0xF, 0xC)
            | (0xF, 0xD)
            | (0xD, 0xD)
            | (0xE, 0xD) => Self::Nop,
            (0x10.., _) => panic!("cannot execute {op:x}"),
            (_, 0x10..) => panic!("cannot execute {op:x}"),
        }
    }
}
#[derive(Clone, Debug)]
pub struct Load16 {
    pub load_into: V16,
    pub from: (V8, V8),
}
